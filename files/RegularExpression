-g global flag many use 
/m multi-line  mode ^$ work with don't care about new line

----BASE---------
^  start
$ end
\A start of string never end of line
\Z end of string never end of line

. all chars
[abc.xyz]  in set . is not all char but simple dot .
\. escape charakter
\t tab
\r \n \r\n new line

[abc]  find a b c but not abc  SINGLE!
[0-9] range but one
[A-Za-z]
[50-99] its 5 0-9 and 9 not increment same like [0-9]
^ negate a character set
[^abc] not abc
/see[^mn]/ matches "see " but not "see"

-------SHORT------
\d [0-9]
\w [a-zA-Z0-9_]
\s [ \t\r\n]
\D [^0-9]
\W [^a-zA-Z0-9_]
\S [^ \t\r\n]

-----REPETITION------

* zero or more time
+ one or more time
? zero or one time

{min,max} repeat
\d{4,8}
\d{4} exactly 4 time
\d{4,} min 4 and infinite

---strategy--
greedy default
? lazy
/apples??/ prefere lazy so take apple coz lazy
 /.*?[0-9]*?/ ,match nothing coz lazy all optional !!!
*?
+?

---GROUPS-----

(abc)+  abcabcabc
(in)?test = intest, test
(abc){3} 3x abc

--------------
| or
(test|abc)
(aa|bb|cc){3} aaaacc
left prefer performance
--------------

/b word boundary
/B not word boundary

boundary between strings abc cde

/\B\w+\B/  This is test = hi es


/1 /2 reference to catch smth

<(i|em)>.+?</\1> reference to (i|em)


 







 
